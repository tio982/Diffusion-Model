# -*- coding: utf-8 -*-
"""data

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hMNabzHIv9Ou9Mlr_xSJwcNpZEe_C2yr
"""

import torch
import torchvision
import numpy as np
import torchvision.transforms as transforms
from torch.utils.data import Subset, DataLoader
from utils import save_images_as_artifact

def load_data():
    
    class1_index=4
    class2_index=9
    num_images=500
    
    # Load CIFAR-10 dataset
    transform = torchvision.transforms.Compose([
        torchvision.transforms.ToTensor()
    ])

    trainset = torchvision.datasets.CIFAR10(root='./data', train=True, download=True, transform=transform)

    # Select images from chosen classes
    class_names = trainset.classes

    # Initialize lists to store indices of selected images
    class1_indices = []
    class2_indices = []

    # Iterate through the dataset to find images belonging to the selected classes
    for idx, (image, label) in enumerate(trainset):
        if label == class1_index:
            class1_indices.append(idx)
        elif label == class2_index:
            class2_indices.append(idx)

    # Select 500 random images from each class
    selected_indices_class1 = np.random.choice(class1_indices, size=num_images, replace=False)
    selected_indices_class2 = np.random.choice(class2_indices, size=num_images, replace=False)

    # Combine the selected indices from both classes
    selected_indices = np.concatenate((selected_indices_class1, selected_indices_class2), axis=0)

    # Create a Subset of the original dataset using the selected indices
    train_subset = Subset(trainset, selected_indices)

    # Define transformations and augmentations
    transformations = transforms.Compose([
        transforms.RandomHorizontalFlip(),  # Randomly flip the image horizontally
        transforms.RandomRotation(10),       # Randomly rotate the image by up to 10 degrees
        transforms.ToTensor(),               # Convert the image to tensor
        transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))  # Normalize the image
    ])

    # Apply transformations to the train_subset
    train_subset.transform = transformations

    # Save original images as a W&B artifact
    save_images_as_artifact(train_subset, 'original_images')

    # Create a DataLoader for the augmented training set
    train_loader = torch.utils.data.DataLoader(train_subset, batch_size=32, shuffle=True)

    return train_loader